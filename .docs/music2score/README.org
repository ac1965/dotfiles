#+title: ğŸ¶ éŸ³æºã‹ã‚‰MIDIã¨è­œé¢ã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
#+author: YAMASHITA, Takao
#+language: ja
#+property: header-args :comments link :mkdirp yes
#+startup: show2levels indent

* ã¯ã˜ã‚ã«
ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆWAV, MP3, AIFCãªã©ï¼‰ã‹ã‚‰  
**ã‚¹ãƒ†ãƒ åˆ†é›¢ â†’ MIDIå¤‰æ› â†’ æ­Œè©æŠ½å‡º â†’ è­œé¢åŒ–(MusicXML)**  
ã¾ã§ã‚’è‡ªå‹•ã§è¡Œã† macOS å‘ã‘ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ã™ã€‚

ä¸»ãªæ§‹æˆè¦ç´ ï¼š
- **UVR5**ï¼šãƒœãƒ¼ã‚«ãƒ«ãƒ»æ¥½å™¨ã®åˆ†é›¢  
- **NeuralNote**ï¼šæ¥½å™¨ã‚’MIDIåŒ–ï¼ˆGUIæ“ä½œï¼‰  
- **process.sh**ï¼šãƒœãƒ¼ã‚«ãƒ«ã®è‡ªå‹•å‡¦ç†ï¼ˆMIDI + æ­Œè© + MusicXMLï¼‰  
- **MuseScore**ï¼šæœ€çµ‚çš„ãªè­œé¢ç¢ºèªç”¨

* ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆ
#+begin_src text
project-root/
â”œâ”€â”€ README.org               # ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆï¼ˆtangleå¯¾å¿œï¼‰
â”œâ”€â”€ Makefile                 # make run ã§å®Ÿè¡Œã§ãã‚‹
â”œâ”€â”€ process.sh               # éŸ³å£°â†’MIDI/SRT/MusicXML è‡ªå‹•å‡¦ç†
â”œâ”€â”€ full_music_pipeline.sh   # ã‚¹ãƒ†ãƒ åˆ†é›¢ã‹ã‚‰å…¨è‡ªå‹•
â”œâ”€â”€ requirements.txt         # Pythonä¾å­˜ãƒªã‚¹ãƒˆ
â””â”€â”€ out/
    â”œâ”€â”€ stems/               # UVR5 å‡ºåŠ›
    â”œâ”€â”€ midi/                # NeuralNote å‡ºåŠ›
    â”œâ”€â”€ vocals_basic_pitch.mid
    â”œâ”€â”€ vocals.srt
    â””â”€â”€ vocals_with_lyrics.musicxml
#+end_src

* ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆåˆå›ã®ã¿ï¼‰
macOS / Linux å…±é€šã§ä»¥ä¸‹ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚

#+begin_src bash
# Homebrew ãŒãªã‘ã‚Œã°å…ˆã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# å¿…è¦ãƒ„ãƒ¼ãƒ«
brew install ffmpeg

# ä»®æƒ³ç’°å¢ƒã‚’ä½œæˆã—ã¦ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
python3 -m venv .venv
source .venv/bin/activate

# ä¾å­˜é–¢ä¿‚ã‚’ã¾ã¨ã‚ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
pip install --upgrade pip setuptools wheel
pip install -r requirements.txt
#+end_src

* requirements.txt :tangle requirements.txt
:PROPERTIES:
:header-args: :tangle requirements.txt :mkdirp yes
:END:
#+begin_src text
# Audio to MIDI / Lyrics / Score Pipeline dependencies
uvr5
basic-pitch
faster-whisper
music21
mido
srt
librosa
soundfile
numpy
scipy
tqdm
requests
torch
torchaudio
onnxruntime
#+end_src

* å‡¦ç†ãƒ•ãƒ­ãƒ¼ï¼ˆMermaidï¼‰
#+begin_src mermaid
flowchart TD
    A[ğŸµ éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«] --> B[ğŸ› UVR5 ã‚¹ãƒ†ãƒ åˆ†é›¢]
    B -->|vocals.wav| C1[ğŸ¤ ãƒœãƒ¼ã‚«ãƒ«]
    B -->|piano/bass/drums.wav| C2[ğŸ¹ æ¥½å™¨ç¾¤]
    C2 --> D[ğŸ§  NeuralNote<br>Audioâ†’MIDI (GUI)]
    D --> E[ğŸ’¾ æ¥½å™¨MIDIå‡ºåŠ›]
    C1 --> F[âš™ï¸ process.sh]
    F --> F1[ğŸ¶ Basic Pitch<br>éŸ³å£°â†’MIDI]
    F --> F2[ğŸ—£ Faster-Whisper<br>éŸ³å£°â†’SRT(æ­Œè©)]
    F --> F3[ğŸ§© music21<br>MIDI+SRTâ†’MusicXML]
    F3 --> G[ğŸ“„ æ­Œè©ä»˜ãè­œé¢(MusicXML)]
    F3 --> H[ğŸ¼ MuseScore ã§é–‹ã]
    E --> I[ğŸš DAWã¸ã‚¤ãƒ³ãƒãƒ¼ãƒˆ]
    G --> I
    I --> J[ğŸµ å®Œæˆï¼ï¼ˆã‚¹ã‚³ã‚¢ï¼‹MIDIçµ±åˆï¼‰]
#+end_src

* å®Ÿè¡Œæ–¹æ³•
#+begin_src bash
# å®Ÿè¡Œæ¨©é™ã‚’ä»˜ä¸
chmod +x process.sh full_music_pipeline.sh

# éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®šã—ã¦ãƒ•ãƒ«ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ
make run INPUT="my_song.wav" OUT="out"
#+end_src

* process.sh :tangle process.sh
:PROPERTIES:
:header-args: :tangle process.sh :mkdirp yes
:END:
#+begin_src bash
#!/usr/bin/env bash
# éŸ³å£°â†’MIDIâ†’SRTâ†’MusicXMLï¼ˆæ­Œè©é€£æºï¼‰ã‚’è‡ªå‹•å®Ÿè¡Œ
set -euo pipefail

AUDIO_IN=""
OUT_DIR=""
WHISPER_MODEL="medium"
LANG="ja"
OPEN_MSCORE="false"
VENV_DIR=".venv-process"
BASIC_PITCH_OUT_SUB="midi"

while [[ $# -gt 0 ]]; do
  case "$1" in
    -i|--input) AUDIO_IN="$2"; shift 2 ;;
    -o|--out) OUT_DIR="$2"; shift 2 ;;
    --lang) LANG="$2"; shift 2 ;;
    --whisper-model) WHISPER_MODEL="$2"; shift 2 ;;
    --open-mscore) OPEN_MSCORE="true"; shift ;;
    *) echo "Usage: ./process.sh -i <audio> -o <out> [--lang ja] [--whisper-model medium] [--open-mscore]"; exit 1 ;;
  esac
done

[[ -z "$AUDIO_IN" || -z "$OUT_DIR" ]] && { echo "[ERR] -i/--input ã¨ -o/--out ã¯å¿…é ˆã§ã™"; exit 1; }

mkdir -p "$OUT_DIR"
ABS_OUT="$(cd "$OUT_DIR" && pwd)"

if [[ ! -d "$VENV_DIR" ]]; then
  echo "[INFO] Python venv ä½œæˆä¸­..."
  python3 -m venv "$VENV_DIR"
fi
source "$VENV_DIR/bin/activate"
pip install -q --upgrade pip setuptools wheel
pip install -q -r requirements.txt

BASENAME="$(basename "$AUDIO_IN")"
STEM="${BASENAME%.*}"
WORK_WAV="$ABS_OUT/${STEM}_44100mono.wav"

echo "[INFO] 44.1kHz mono WAV ã«å¤‰æ›: $WORK_WAV"
ffmpeg -y -i "$AUDIO_IN" -ac 1 -ar 44100 -vn "$WORK_WAV" >/dev/null 2>&1

MIDI_DIR="$ABS_OUT/$BASIC_PITCH_OUT_SUB"
mkdir -p "$MIDI_DIR"
echo "[INFO] Basic Pitch å®Ÿè¡Œä¸­..."
basic-pitch "$WORK_WAV" --output-dir "$MIDI_DIR" >/dev/null
MIDI_PATH="$(ls "$MIDI_DIR"/*_basic_pitch.mid | head -n 1)"
[[ -z "$MIDI_PATH" ]] && { echo "[ERR] MIDI å‡ºåŠ›ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"; exit 1; }

ASR_DIR="$ABS_OUT/lyrics"
mkdir -p "$ASR_DIR"
echo "[INFO] Faster-Whisper å®Ÿè¡Œä¸­..."
faster-whisper-transcribe --model "$WHISPER_MODEL" --language "$LANG" --task transcribe \
  --vad_filter True --output_format srt --output_dir "$ASR_DIR" "$WORK_WAV" >/dev/null 2>&1 || true

SRT_PATH="$(ls "$ASR_DIR"/*.srt | head -n 1)"
[[ -z "$SRT_PATH" ]] && { echo "[ERR] SRT ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"; exit 1; }

XML_OUT="$ABS_OUT/${STEM}_with_lyrics.musicxml"
echo "[INFO] MusicXML ç”Ÿæˆä¸­..."
python3 - "$MIDI_PATH" "$SRT_PATH" "$XML_OUT" <<'PY'
import sys,re,srt
from music21 import converter,note
midi,srtf,xml=sys.argv[1:]
sc=converter.parse(midi)
melody=max(sc.parts,key=lambda p:len(p.recurse().getElementsByClass(note.Note)))
notes=list(melody.recurse().getElementsByClass(note.Note))
subs=list(srt.parse(open(srtf,encoding='utf-8').read()))
words=[]
for sub in subs:
  line=re.sub(r'\s+',' ',sub.content.strip())
  for w in line.split(' '):
    for i,s in enumerate(w.split('-')):
      if s: words.append(s if i==len(w.split('-'))-1 else s+'-')
for i,n in enumerate(notes):
  if i>=len(words): break
  n.lyric=words[i]
sc.write('musicxml',fp=xml)
PY

echo "[OK] å‡ºåŠ›å®Œäº†:"
echo " - MIDI: $MIDI_PATH"
echo " - SRT:  $SRT_PATH"
echo " - XML:  $XML_OUT"

[[ "$OPEN_MSCORE" == "true" ]] && open -a "MuseScore 4" "$XML_OUT" || true
#+end_src

* full_music_pipeline.sh :tangle full_music_pipeline.sh
:PROPERTIES:
:header-args: :tangle full_music_pipeline.sh :mkdirp yes
:END:
#+begin_src bash
#!/usr/bin/env bash
# éŸ³æºâ†’ã‚¹ãƒ†ãƒ åˆ†é›¢â†’NeuralNoteâ†’process.sh å…¨è‡ªå‹•åŒ–
set -euo pipefail

AUDIO_IN=""
OUT_DIR=""
LANG="ja"
WHISPER_MODEL="medium"

while [[ $# -gt 0 ]]; do
  case "$1" in
    -i|--input) AUDIO_IN="$2"; shift 2 ;;
    -o|--out) OUT_DIR="$2"; shift 2 ;;
    --lang) LANG="$2"; shift 2 ;;
    --model) WHISPER_MODEL="$2"; shift 2 ;;
    *) echo "Usage: ./full_music_pipeline.sh -i <audio> -o <out>"; exit 1 ;;
  esac
done

[[ -z "$AUDIO_IN" || -z "$OUT_DIR" ]] && { echo "[ERR] å…¥åŠ›ã¨å‡ºåŠ›ã¯å¿…é ˆã§ã™"; exit 1; }

ABS_OUT="$(cd "$OUT_DIR" && pwd)"
mkdir -p "$ABS_OUT"

echo "[STEP1] UVR5ã§ã‚¹ãƒ†ãƒ åˆ†é›¢"
python3 -m uvr5 --input "$AUDIO_IN" --output "$ABS_OUT/stems" \
  --model "MDX-Net_Inst_HQ_3,MDX-Net_Voc_FT,MDX-Net_Drums" >/dev/null 2>&1 || {
  echo "[WARN] UVR5 CLI ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹å¤±æ•—ã—ã¾ã—ãŸ"
}

echo "[STEP2] NeuralNoteã§æ¥½å™¨MIDIåŒ–ï¼ˆæ‰‹å‹•ï¼‰"
read -p "NeuralNote ã§å‡ºåŠ›ãŒçµ‚ã‚ã£ãŸã‚‰ Enter ã‚’æŠ¼ã—ã¦ãã ã•ã„: " _

VOCAL_STEM="$(ls "$ABS_OUT/stems"/*voc* 2>/dev/null | head -n 1 || true)"
[[ -z "$VOCAL_STEM" ]] && VOCAL_STEM="$AUDIO_IN"

echo "[STEP3] process.sh ã‚’å®Ÿè¡Œ"
./process.sh -i "$VOCAL_STEM" -o "$ABS_OUT" --lang "$LANG" --whisper-model "$WHISPER_MODEL" --open-mscore

echo "âœ… å®Œäº†: å‡ºåŠ›ã¯ $ABS_OUT ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸ"
#+end_src

* Makefile :tangle Makefile
:PROPERTIES:
:header-args: :tangle Makefile :mkdirp yes
:END:
#+begin_src makefile
INPUT ?= song.wav
OUT ?= out

run:
	@echo "=== ãƒ•ãƒ«ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œä¸­ ==="
	@./full_music_pipeline.sh -i "$(INPUT)" -o "$(OUT)" --lang ja --model medium
	@echo "=== å®Œäº†: å‡ºåŠ›ã¯ $(OUT) ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸ ==="

clean:
	rm -rf .venv-process .venv out
#+end_src
