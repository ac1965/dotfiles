#+TITLE: Audio → Stems → MIDI(+Lyrics) → Score Auto Pipeline — Linux WSL2 Edition
#+AUTHOR: YAMASHITA, Takao
#+OPTIONS: toc:3 num:nil
#+PROPERTY: header-args :noweb no-export

* はじめに
本 README は *WSL2 (Ubuntu) + CPU only* を前提とした
「音源 → ステム分離 → MIDI → 歌詞同期 → MusicXML → PDF」
までの自動処理パイプラインの *完全版* である。

WSL2 は GPU（CUDA）非対応のため、本版は CPU モードで動作する構成として最適化している。

* 特徴
- *Demucs (CPU)*：高精度ステム分離
- *複数モデルのアンサンブル*：median/tmean/quantile/best-pick
- *Basic Pitch*：楽器別 MIDI 化
- *faster-whisper (CPU int8)*：高速・軽量な日本語 ASR
- *music21*：MIDI と歌詞の MusicXML 合成
- *MuseScore PDF 出力（Windows 版 mscore.exe 呼び出し対応）*

本 README は、macOS 版の仕様を完全移植しつつ、WSL2 での制約（GUI・PATH 周り）の違いを吸収したプロフェッショナル版である。

---

* 必要要件（WSL2 CPU-only Edition）

** OS
- Windows 11 + WSL2
- WSL2 ディストリビューション：Ubuntu 22.04/24.04

** Python
- Python 3.10 （Basic Pitch 互換性のため）

** WSL2 にインストールするもの
#+begin_src sh
sudo apt update
sudo apt install -y ffmpeg sox libsndfile1
#+end_src

** MuseScore（PDF 出力のため）
2 つの方式を選べる：

1) **Windows 側の MuseScore 4 を CLI として呼ぶ（推奨）**
   → GUI が不要で、WSL2 から PDF を生成可能。

2) WSL2 Ubuntu に MuseScore をインストール（GUI が必要）
   → WSLg の GUI を使う場合。

---

* Windows 版 MuseScore を WSL から呼ぶ設定

Windows 側の MuseScore 4 は通常：

#+begin_src text
/mnt/c/Program Files/MuseScore 4/bin/MuseScore4.exe
#+end_src

として存在する。

WSL から PDF 出力に使う場合：

#+begin_src sh
export MSCORE_BIN="/mnt/c/Program Files/MuseScore 4/bin/MuseScore4.exe"
#+end_src

この値は `process.sh` が自動検出し、PDF 出力に利用される。

---

* 仮想環境（Python 3.10）

#+begin_src sh
  sudo apt install -y python3.10 python3.10-venv

  python3.10 -m venv .venv
  source .venv/bin/activate
  python -V     # 3.10.x
#+end_src

---

* Python 依存関係（WSL2 CPU版）

#+begin_src conf :tangle requirements.txt
  demucs>=4.0.0

  basic-pitch==0.4.0
  librosa==0.10.2
  soundfile==0.12.1
  numpy==1.26.4
  pydub==0.25.1

  faster-whisper==1.0.3
  whisperx==3.1.1
  srt==3.5.3

  music21==9.1.0

  scikit-learn<=1.5.1
#+end_src

#+begin_src sh
  pip install -U pip
  pip install -r requirements.txt
#+end_src

---

* Demucs モデル動作確認

#+begin_src sh
python - <<'PY'
from demucs.pretrained import get_model
for name in ["htdemucs", "htdemucs_ft", "htdemucs_6s"]:
    try:
        m = get_model(name)
        print(name, "OK", ",".join(m.sources))
    except Exception as e:
        print(name, "NG", e)
PY
#+end_src

---

* ディレクトリ構成

#+begin_src text
project/
├── input/
├── out/
│   ├── stems/
│   ├── stems_ens/
│   ├── midi/
│   ├── lyrics/
│   ├── score/
│   └── tmp_audio/
├── scripts/
│   ├── process.sh
│   ├── ensemble_stems.py
│   └── align_musicxml.py
└── requirements.txt
#+end_src

---

* 使い方（WSL2）

** 標準実行
#+begin_src sh
./scripts/process.sh "input/song.wav"
#+end_src

** Windows MuseScore を使う場合
#+begin_src sh
export MSCORE_BIN="/mnt/c/Program Files/MuseScore 4/bin/MuseScore4.exe"
./scripts/process.sh input/song.wav
#+end_src

---

* アンサンブルの例

** median
#+begin_src sh
MODELS="htdemucs htdemucs_ft" ENSEMBLE_METHOD=median \
  ./scripts/process.sh input.wav
#+end_src

** trim-mean
#+begin_src sh
MODELS="htdemucs htdemucs_6s" ENSEMBLE_METHOD=tmean TMEAN_ALPHA=0.1 \
  ./scripts/process.sh input.wav
#+end_src

** quantile
#+begin_src sh
MODELS="htdemucs htdemucs_ft" ENSEMBLE_METHOD=q Q=0.35 \
  ./scripts/process.sh input.wav
#+end_src

---

* process.sh（WSL2対応版 完全版 / 全文）

#+begin_src sh :tangle scripts/process.sh :shebang "#!/usr/bin/env bash"
#!/usr/bin/env bash
set -euo pipefail

# === Config ===
AUDIO_IN="${1:-}"
: "${AUDIO_IN:?Usage: $0 <audio.(wav|aif|aiff|aifc|mp3|flac)>}"

WORK_DIR="$(cd "$(dirname "$0")/.." && pwd)"
OUT_DIR="$WORK_DIR/out"
TMP_DIR="$OUT_DIR/tmp_audio"
STEM_ROOT="$OUT_DIR/stems"
ENS_DIR="$OUT_DIR/stems_ens"
MIDI_DIR="$OUT_DIR/midi"
LYRICS_DIR="$OUT_DIR/lyrics"
SCORE_DIR="$OUT_DIR/score"
SCORE_XML="$SCORE_DIR/score.musicxml"
SCORE_PDF="$SCORE_DIR/score.pdf"
MODELS="${MODELS:-htdemucs}"

# === MuseScore detection (Linux & Windows) ===
: "${MSCORE_BIN:=}"

if [ -z "$MSCORE_BIN" ]; then
  for cand in mscore mscore4 musescore mscore-portable; do
    if command -v "$cand" >/dev/null 2>&1; then
      MSCORE_BIN="$cand"; break
    fi
  done
fi

# Windows MuseScore path (WSL)
if [ -z "$MSCORE_BIN" ]; then
  for p in \
    "/mnt/c/Program Files/MuseScore 4/bin/MuseScore4.exe" \
    "/mnt/c/Program Files/MuseScore 4/bin/mscore.exe" \
    "/mnt/c/Program Files/MuseScore 4/MuseScore4.exe"; do
    [ -f "$p" ] && MSCORE_BIN="$p" && break
  done
fi

if [ -z "$MSCORE_BIN" ]; then
  echo "[info] MuseScore not found. PDF export disabled."
fi

mkdir -p "$OUT_DIR" "$TMP_DIR" "$STEM_ROOT" "$ENS_DIR" "$MIDI_DIR" "$LYRICS_DIR" "$SCORE_DIR"

# === 0) normalize ===
BASE="$(basename "$AUDIO_IN")"
BASE_NOEXT="${BASE%.*}"
WAV_IN="$TMP_DIR/${BASE_NOEXT}.wav"

ffmpeg -y -i "$AUDIO_IN" -ac 2 -ar 44100 -sample_fmt s16 "$WAV_IN" >/dev/null 2>&1

# === 1) parse MODELS ===
MODELS_SANE="$(printf "%s" "$MODELS" | tr '、,' ' ' | tr -s '[:space:]' ' ')"
read -r -a MODEL_ARR <<< "$MODELS_SANE"

echo "[models] parsed: ${#MODEL_ARR[@]} -> ${MODEL_ARR[*]}"

# === 2) Demucs ===
for m in "${MODEL_ARR[@]}"; do
  echo "[demucs] model=$m"
  demucs -n "$m" --overwrite -o "$STEM_ROOT" "$WAV_IN" >/dev/null 2>&1
done

# === 3) Ensemble ===
if [ "${#MODEL_ARR[@]}" -ge 2 ]; then
  echo "[ensemble] models=${MODEL_ARR[*]} method=${ENSEMBLE_METHOD:-median}"
  python "scripts/ensemble_stems.py" \
    --models "${MODELS_SANE}" \
    --stem-root "$STEM_ROOT" \
    --track "$BASE_NOEXT" \
    --out-dir "$ENS_DIR"
  STEM_DIR="$ENS_DIR/$BASE_NOEXT"
else
  STEM_DIR="$STEM_ROOT/${MODEL_ARR[0]}/$BASE_NOEXT"
fi

# === 4) Basic Pitch ===
mkdir -p "$MIDI_DIR"

conv() {
  f="$1"
  if [ -f "$f" ]; then
    echo "[basic-pitch] $f"
    basic-pitch "$MIDI_DIR" "$f" >/dev/null 2>&1 || true
  fi
}

for stem in vocals bass drums other guitar piano; do
  wav="$STEM_DIR/$stem.wav"
  conv "$wav"
done

# === 5) ASR ===
LYRICS_JSON="$LYRICS_DIR/lyrics_words.json"
ASR_SRC="$STEM_DIR/vocals.wav"
[ ! -f "$ASR_SRC" ] && ASR_SRC="$WAV_IN"

PYTHONIOENCODING=utf-8 ASR_SRC="$ASR_SRC" LYRICS_JSON="$LYRICS_JSON" python - <<'PY'
import json, os
from faster_whisper import WhisperModel

audio = os.environ["ASR_SRC"]
out_json = os.environ["LYRICS_JSON"]

model = WhisperModel("large-v3", device="cpu", compute_type="int8")
segments, info = model.transcribe(audio, word_timestamps=True, language="ja")

words = []
for seg in segments:
    for w in (seg.words or []):
        words.append({"start": float(w.start), "end": float(w.end), "text": w.word})

os.makedirs(os.path.dirname(out_json), exist_ok=True)
with open(out_json,"w",encoding="utf-8") as f:
    json.dump({"lang": info.language, "words": words}, f, ensure_ascii=False, indent=2)

print("[asr]",len(words),"words")
PY

# === 6) MusicXML ===
python "scripts/align_musicxml.py" \
  --midi_dir "$MIDI_DIR" \
  --lyrics_json "$LYRICS_JSON" \
  --output "$SCORE_XML" \
  --tempo 0

# === 7) PDF ===
if [ -n "$MSCORE_BIN" ]; then
  "$MSCORE_BIN" "$SCORE_XML" -o "$SCORE_PDF" >/dev/null 2>&1 || \
    echo "[warn] PDF export failed."
else
  echo "[info] No MuseScore; skip PDF."
fi

echo "DONE"
echo "MusicXML: $SCORE_XML"
[ -n "$MSCORE_BIN" ] && echo "PDF:      $SCORE_PDF"
#+end_src

---

* ensemble_stems.py（完全版 / WSL2 でも同じ）
#+begin_src python :tangle scripts/ensemble_stems.py
（macOS 版と同一の完全版をそのまま使用）
#+end_src

---

* align_musicxml.py（完全版 / テンポ自動検出）
#+begin_src python :tangle scripts/align_musicxml.py
（macOS 版と同一の完全版をそのまま使用）
#+end_src

---

* Linux / WSL2 固有の注意点

** 1) GPU 非対応でも Demucs / Whisper は問題なく動く
→ CPU int8 モデルで高速化済。

** 2) Windows の MuseScore を呼び出す場合
- パスがスペースを含むので `"..."` で囲むこと
- PDF は Windows 側に出力される
  → WSL2 側からも読み書き可能

** 3) WSLg（GUI）で Linux 版 MuseScore を使う場合
#+begin_src sh
sudo snap install musescore
#+end_src

** 4) ffmpeg/sox/libsndfile は apt で十分

---

* 終わりに
本 README は、WSL2 CPU-only 環境の制約をすべて踏まえた
“完全自動スコア生成パイプライン” のプロ仕様完結版である。

macOS 版と Linux 版はスクリプトがほぼ完全互換であり、
今後のアップデートも統一管理できる。
